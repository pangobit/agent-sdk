package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestCLI_Help(t *testing.T) {
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-help")
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("Help command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "USAGE:") {
		t.Error("Help output should contain USAGE section")
	}
	if !strings.Contains(outputStr, "-stdout") {
		t.Error("Help output should mention stdout flag")
	}
	if !strings.Contains(outputStr, "-package") {
		t.Error("Help output should mention package flag")
	}
}

func TestCLI_MissingRequiredOptions(t *testing.T) {
	// Test missing -const
	cmd := exec.Command("go", "run", ".", "-package=../../examples/apigen_go_generate", "-stdout")
	output, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("Expected command to fail with missing -const")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "constant name (-const) is required") {
		t.Errorf("Expected error about missing const, got: %s", outputStr)
	}
}

func TestCLI_ConflictingInputOptions(t *testing.T) {
	// Test both -package and -file specified
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-file=test.go", "-const=TestAPI", "-stdout")
	output, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("Expected command to fail with conflicting input options")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "cannot specify both -package and -file") {
		t.Errorf("Expected error about conflicting input options, got: %s", outputStr)
	}
}

func TestCLI_ConflictingOutputOptions(t *testing.T) {
	// Test both -out and -stdout specified
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-out=test.go", "-stdout", "-const=TestAPI")
	output, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("Expected command to fail with conflicting output options")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "cannot specify both -out and -stdout") {
		t.Errorf("Expected error about conflicting output options, got: %s", outputStr)
	}
}

func TestCLI_PackageInputStdoutOutput(t *testing.T) {
	cmd := exec.Command("go", "run", ".", "-package=../../examples/apigen_go_generate", "-stdout", "-const=TestAPI", "-prefix=Process")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "// Code generated by apigen") {
		t.Error("Output should contain generated code header")
	}
	if !strings.Contains(outputStr, "const TestAPI = ") {
		t.Error("Output should contain the generated constant")
	}
	if !strings.Contains(outputStr, "ProcessUserData") {
		t.Error("Output should contain ProcessUserData method")
	}
	if !strings.Contains(outputStr, `"apiName": "apigen_go_generate"`) {
		t.Error("Output should contain correct API name")
	}
}

func TestCLI_FileInputStdoutOutput(t *testing.T) {
	cmd := exec.Command("go", "run", ".", "-file=../../examples/apigen_go_generate/main.go", "-stdout", "-const=TestAPI", "-prefix=Process")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "const TestAPI = ") {
		t.Error("Output should contain the generated constant")
	}
	if !strings.Contains(outputStr, "ProcessUserData") {
		t.Error("Output should contain ProcessUserData method")
	}
}

func TestCLI_MethodListFilter(t *testing.T) {
	cmd := exec.Command("go", "run", ".", "-package=../../examples/apigen_go_generate", "-stdout", "-const=TestAPI", "-methods=ProcessUserData")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "ProcessUserData") {
		t.Error("Output should contain ProcessUserData method")
	}
	if strings.Contains(outputStr, "ValidateInput") {
		t.Error("Output should not contain ValidateInput method")
	}
}

func TestCLI_PrefixFilter(t *testing.T) {
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-stdout", "-const=TestAPI", "-prefix=Process")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "ProcessUserData") {
		t.Error("Output should contain ProcessUserData method")
	}
	if strings.Contains(outputStr, "ValidateInput") {
		t.Error("Output should not contain ValidateInput method")
	}
}

func TestCLI_ContainsFilter(t *testing.T) {
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-stdout", "-const=TestAPI", "-contains=User")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "ProcessUserData") {
		t.Error("Output should contain ProcessUserData method")
	}
	if strings.Contains(outputStr, "ValidateInput") {
		t.Error("Output should not contain ValidateInput method")
	}
}

func TestCLI_MapGenerator(t *testing.T) {
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-stdout", "-const=TestAPIMap", "-prefix=Process", "-map")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "var TestAPIMap = map[string]string{") {
		t.Error("Output should contain map declaration")
	}
	if !strings.Contains(outputStr, "GetMethodDescription") {
		t.Error("Output should contain GetMethodDescription function")
	}
	if !strings.Contains(outputStr, `"ProcessUserData": `) {
		t.Error("Output should contain ProcessUserData in map")
	}
}

func TestCLI_FileOutput(t *testing.T) {
	// Create temp file
	tmpFile, err := os.CreateTemp("", "apigen_test_*.go")
	if err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}
	defer os.Remove(tmpFile.Name())
	tmpFile.Close()

	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-out="+tmpFile.Name(), "-const=TestAPI", "-prefix=Process")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	expectedMsg := "Generated " + tmpFile.Name() + " with constant TestAPI"
	if !strings.Contains(outputStr, expectedMsg) {
		t.Errorf("Expected output message '%s', got: %s", expectedMsg, outputStr)
	}

	// Check file contents
	content, err := os.ReadFile(tmpFile.Name())
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	contentStr := string(content)
	if !strings.Contains(contentStr, "// Code generated by apigen") {
		t.Error("Generated file should contain code header")
	}
	if !strings.Contains(contentStr, "const TestAPI = ") {
		t.Error("Generated file should contain the constant")
	}
}

func TestCLI_CustomAPIName(t *testing.T) {
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-stdout", "-const=TestAPI", "-api-name=MyCustomAPI", "-prefix=Process")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, `"apiName": "MyCustomAPI"`) {
		t.Error("Output should contain custom API name")
	}
}

func TestCLI_NoPackageOrFileSpecified(t *testing.T) {
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-const=TestAPI", "-stdout")
	output, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("Expected command to fail with no input specified")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "either package path (-package) or file path (-file) is required") {
		t.Errorf("Expected error about missing input, got: %s", outputStr)
	}
}

func TestCLI_NoOutputSpecified(t *testing.T) {
	cmd := exec.Command("go", "run", "../../cmd/apigen", "-package=./examples/apigen_go_generate", "-const=TestAPI")
	output, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("Expected command to fail with no output specified")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "either output file (-out) or stdout (-stdout) is required") {
		t.Errorf("Expected error about missing output, got: %s", outputStr)
	}
}

func TestCLI_InvalidPackagePath(t *testing.T) {
	cmd := exec.Command("go", "run", ".", "-package=./nonexistent/package", "-stdout", "-const=TestAPI")
	output, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("Expected command to fail with invalid package path")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "Failed to generate") {
		t.Errorf("Expected parse error, got: %s", outputStr)
	}
}

func TestCLI_InvalidFilePath(t *testing.T) {
	cmd := exec.Command("go", "run", ".", "-file=./nonexistent/file.go", "-stdout", "-const=TestAPI")
	output, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("Expected command to fail with invalid file path")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "Failed to generate") {
		t.Errorf("Expected parse error, got: %s", outputStr)
	}
}

// Test with a temporary Go file to test file input
func TestCLI_WithTempGoFile(t *testing.T) {
	// Create a temporary Go file
	tmpDir, err := os.MkdirTemp("", "apigen_test_")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	tmpFile := filepath.Join(tmpDir, "test.go")
	goCode := `package main

// TestMethod is a test method
func TestMethod(param string) error {
	return nil
}
`
	err = os.WriteFile(tmpFile, []byte(goCode), 0644)
	if err != nil {
		t.Fatalf("Failed to write temp file: %v", err)
	}

	cmd := exec.Command("go", "run", "../../cmd/apigen", "-file="+tmpFile, "-stdout", "-const=TestAPI")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Command failed: %v", err)
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "TestMethod") {
		t.Error("Output should contain TestMethod")
	}
	if !strings.Contains(outputStr, `"param":`) {
		t.Error("Output should contain parameter information")
	}
}