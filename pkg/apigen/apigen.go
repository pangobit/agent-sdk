// Package apigen provides functionality to automatically generate JSON-friendly API descriptions
// from Go source code. It analyzes Go packages and files to extract method signatures,
// parameter types, struct fields, and struct tag annotations to create comprehensive
// API documentation that can be consumed by client libraries or used for runtime
// API introspection.
//
// Key features:
//   - Parse Go packages or individual files
//   - Extract method descriptions from Go doc comments
//   - Analyze parameter types including complex structs
//   - Parse struct tags and include them as annotations
//   - Filter methods using various strategies (prefix, suffix, contains, explicit list)
//   - Generate Go files with embedded API definitions for runtime use
//   - CLI tool for easy integration with go:generate
//
// Example usage:
//
//	import "github.com/pangobit/agent-sdk/pkg/apigen"
//
//	config := apigen.WithPrefix("Handle")
//	desc, err := apigen.GenerateFromPackage("./pkg/handlers", config)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// For go:generate integration, see the cmd/apigen CLI tool.
package apigen

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"maps"
	"os"
	"path/filepath"
	"strings"
)

// GenerateFromPackage generates API description from a Go package
func GenerateFromPackage(packagePath string, config GeneratorConfig) (*APIDescription, error) {
	fset := token.NewFileSet()

	// Parse the package
	pkgs, err := parser.ParseDir(fset, packagePath, func(info os.FileInfo) bool {
		return strings.HasSuffix(info.Name(), ".go") && !strings.HasSuffix(info.Name(), "_test.go")
	}, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse package: %w", err)
	}

	// Collect all methods from all files
	allMethods := make(map[string]*ast.FuncDecl)

	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			methods := extractMethods(file)
			maps.Copy(allMethods, methods)
		}
	}

	// Collect all type definitions from all files in the package
	allTypeDefs := collectAllTypeDefinitions(pkgs, fset)

	// Filter methods based on strategy
	filteredMethods := filterMethods(allMethods, config)

	// Generate descriptions
	methods := make(map[string]MethodDescription)

	for name, method := range filteredMethods {
		desc, err := generateMethodDescription(method, fset, allTypeDefs)
		if err != nil {
			return nil, fmt.Errorf("failed to generate description for %s: %w", name, err)
		}
		methods[name] = desc
	}

	apiDesc := &APIDescription{
		APIName: config.APIName,
		Methods: methods,
	}

	if apiDesc.APIName == "" {
		// Use package name as default
		for pkgName := range pkgs {
			apiDesc.APIName = pkgName
			break
		}
	}

	return apiDesc, nil
}

// GenerateFromFile generates API description from a single Go file
func GenerateFromFile(filePath string, config GeneratorConfig) (*APIDescription, error) {
	fset := token.NewFileSet()

	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %w", err)
	}

	methods := extractMethods(file)
	filteredMethods := filterMethods(methods, config)

	// Collect type definitions from the file
	typeDefs := collectTypeDefinitionsFromFile(file)

	// Generate descriptions
	methodDescriptions := make(map[string]MethodDescription)

	for name, method := range filteredMethods {
		desc, err := generateMethodDescription(method, fset, typeDefs)
		if err != nil {
			return nil, fmt.Errorf("failed to generate description for %s: %w", name, err)
		}
		methodDescriptions[name] = desc
	}

	apiDesc := &APIDescription{
		APIName: config.APIName,
		Methods: methodDescriptions,
	}

	if apiDesc.APIName == "" {
		// Use filename (without extension) as default
		base := filepath.Base(filePath)
		apiDesc.APIName = strings.TrimSuffix(base, filepath.Ext(base))
	}

	return apiDesc, nil
}

// GenerateAndWriteGoFile generates API description and writes it to a Go file as a string constant
func GenerateAndWriteGoFile(packagePath, outputFile, constName, packageName string, config GeneratorConfig) error {
	// Generate the API description
	desc, err := GenerateFromPackage(packagePath, config)
	if err != nil {
		return fmt.Errorf("failed to generate API description: %w", err)
	}

	// Convert to JSON
	jsonData, err := json.MarshalIndent(desc, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal to JSON: %w", err)
	}

	// Generate Go file content
	var content strings.Builder
	content.WriteString("// Code generated by apigen; DO NOT EDIT.\n")
	content.WriteString(fmt.Sprintf("// This file contains the API description for %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("// %s contains the JSON API description for this package\n", constName))
	content.WriteString(fmt.Sprintf("const %s = `%s`\n", constName, jsonData))

	// Write to file
	err = os.WriteFile(outputFile, []byte(content.String()), 0o644)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %w", outputFile, err)
	}

	return nil
}

// GenerateAndWriteGoFileFromFile generates API description from a single file and writes it to a Go file as a string constant
func GenerateAndWriteGoFileFromFile(inputFile, outputFile, constName, packageName string, config GeneratorConfig) error {
	// Generate the API description
	desc, err := GenerateFromFile(inputFile, config)
	if err != nil {
		return fmt.Errorf("failed to generate API description: %w", err)
	}

	// Convert to JSON
	jsonData, err := json.MarshalIndent(desc, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal to JSON: %w", err)
	}

	// Generate Go file content
	var content strings.Builder
	content.WriteString("// Code generated by apigen; DO NOT EDIT.\n")
	content.WriteString(fmt.Sprintf("// This file contains the API description for %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("// %s contains the JSON API description for this file\n", constName))
	content.WriteString(fmt.Sprintf("const %s = `%s`\n", constName, jsonData))

	// Write to file
	err = os.WriteFile(outputFile, []byte(content.String()), 0o644)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %w", outputFile, err)
	}

	return nil
}

// GenerateAndWriteGoFileAsMap generates API description and writes it to a Go file as a map[string]string constant where each key is a method name and each value is a JSON string containing description and parameters (omitting apiName field entirely)
func GenerateAndWriteGoFileAsMap(packagePath, outputFile, constName, packageName string, config GeneratorConfig) error {
	// Generate the API description
	desc, err := GenerateFromPackage(packagePath, config)
	if err != nil {
		return fmt.Errorf("failed to generate API description: %w", err)
	}

	// Generate Go file content
	var content strings.Builder
	content.WriteString("// Code generated by apigen; DO NOT EDIT.\n")
	content.WriteString(fmt.Sprintf("// This file contains the API description for %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("// %s contains the API description as a map of method names to JSON strings\n", constName))
	content.WriteString(fmt.Sprintf("var %s = map[string]string{\n", constName))

	// Add each method as a key-value pair
	for methodName, methodDesc := range desc.Methods {
		// Marshal just the method description (description + parameters)
		jsonData, err := json.MarshalIndent(methodDesc, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal method %s: %w", methodName, err)
		}

		content.WriteString(fmt.Sprintf("\t\"%s\": `%s`,\n", methodName, jsonData))
	}

	content.WriteString("}\n")

	// Write to file
	err = os.WriteFile(outputFile, []byte(content.String()), 0o644)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %w", outputFile, err)
	}

	return nil
}

// GenerateAndWriteGoFileFromFileAsMap generates API description from a single file and writes it to a Go file as a map[string]string constant where each key is a method name and each value is a JSON string containing description and parameters (omitting apiName field entirely)
func GenerateAndWriteGoFileFromFileAsMap(inputFile, outputFile, constName, packageName string, config GeneratorConfig) error {
	// Generate the API description
	desc, err := GenerateFromFile(inputFile, config)
	if err != nil {
		return fmt.Errorf("failed to generate API description: %w", err)
	}

	// Generate Go file content
	var content strings.Builder
	content.WriteString("// Code generated by apigen; DO NOT EDIT.\n")
	content.WriteString(fmt.Sprintf("// This file contains the API description for %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	content.WriteString(fmt.Sprintf("// %s contains the API description as a map of method names to JSON strings\n", constName))
	content.WriteString(fmt.Sprintf("var %s = map[string]string{\n", constName))

	// Add each method as a key-value pair
	for methodName, methodDesc := range desc.Methods {
		// Marshal just the method description (description + parameters)
		jsonData, err := json.MarshalIndent(methodDesc, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal method %s: %w", methodName, err)
		}

		content.WriteString(fmt.Sprintf("\t\"%s\": `%s`,\n", methodName, jsonData))
	}

	content.WriteString("}\n")

	// Write to file
	err = os.WriteFile(outputFile, []byte(content.String()), 0o644)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %w", outputFile, err)
	}

	return nil
}
